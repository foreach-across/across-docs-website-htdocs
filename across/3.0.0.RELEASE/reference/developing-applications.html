<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<title>Developing Across applications</title>
<link rel="stylesheet" href="stylesheets/across.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css">
<link rel="stylesheet" href="stylesheets/coderay-asciidoctor.css">
</head>
<body id="developing-across-applications" class="book toc2 toc-left">
<div id="header">
<h1>Developing Across applications</h1>
<div class="details">
<span id="revnumber">version 3.0.0.RELEASE</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Developing applications</div>
<ul class="sectlevel1">
<li><a href="#creating-across-application">1. Creating an Across application</a>
<ul class="sectlevel2">
<li><a href="#across-application-fundamentals">1.1. Fundamentals</a></li>
<li><a href="#enable-across-context">1.2. @EnableAcrossContext</a></li>
<li><a href="#across-application">1.3. @AcrossApplication</a></li>
</ul>
</li>
<li><a href="#module-configuration">2. Module configuration</a></li>
<li><a href="#across-bootstrap">3. Across bootstrap</a>
<ul class="sectlevel2">
<li><a href="#module-bootstrap-order">3.1. Module bootstrap order</a></li>
<li><a href="#installers">3.2. Installers</a></li>
<li><a href="#bootstrap-events">3.3. Bootstrap events</a></li>
</ul>
</li>
<li><a href="#properties">4. Properties</a></li>
<li><a href="#across-datasource">5. Across datasource</a></li>
<li><a href="#events">6. Events</a>
<ul class="sectlevel2">
<li><a href="#subscribing-to-events">6.1. Subscribing to events</a></li>
<li><a href="#publishing-events">6.2. Publishing events</a></li>
<li><a href="#filtering-events">6.3. Filtering events</a></li>
<li><a href="#asynchronous-listeners">6.4. Asynchronous listeners</a></li>
<li><a href="#event-handler-ordering">6.5. Ordering listeners</a></li>
</ul>
</li>
<li><a href="#refreshing">7. Refreshing</a>
<ul class="sectlevel2">
<li><a href="#refreshable">7.1. @Refreshable</a></li>
<li><a href="#post-refresh">7.2. @PostRefresh</a></li>
<li><a href="#refreshable-collection">7.3. @RefreshableCollection</a></li>
<li><a href="#refreshable-registry">7.4. RefreshableRegistry</a></li>
</ul>
</li>
<li><a href="#bean-order">8. Bean order</a></li>
<li><a href="#conversion-service">9. ConversionService</a></li>
<li><a href="#development-mode">10. Development mode</a></li>
<li><a href="#sql-databases">11. Working with SQL databases</a>
<ul class="sectlevel2">
<li><a href="#using-jdbctemplate">11.1. Using JdbcTemplate</a></li>
<li><a href="#jpa-and-spring-data">11.2. JPA and Spring Data</a></li>
</ul>
</li>
<li><a href="#validation">12. Validation</a></li>
<li><a href="#advanced-topics">13. Advanced topics</a>
<ul class="sectlevel2">
<li><a href="#dev-appl-bootstrap-events">13.1. Lifecycle events</a></li>
<li><a href="#customizing-across-bootstrap">13.2. Customizing Across bootstrap</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<h2 id="artifact" class="discrete">Artifact</h2>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;dependencies&gt;</span>
        <span class="tag">&lt;dependency&gt;</span>
           <span class="tag">&lt;groupId&gt;</span>com.foreach.across<span class="tag">&lt;/groupId&gt;</span>
           <span class="tag">&lt;artifactId&gt;</span>across-core<span class="tag">&lt;/artifactId&gt;</span>
           <span class="tag">&lt;version&gt;</span>3.0.0.RELEASE<span class="tag">&lt;/version&gt;</span>
        <span class="tag">&lt;/dependency&gt;</span>
        <span class="tag">&lt;dependency&gt;</span>
           <span class="tag">&lt;groupId&gt;</span>com.foreach.across<span class="tag">&lt;/groupId&gt;</span>
           <span class="tag">&lt;artifactId&gt;</span>across-web<span class="tag">&lt;/artifactId&gt;</span>
           <span class="tag">&lt;version&gt;</span>3.0.0.RELEASE<span class="tag">&lt;/version&gt;</span>
       <span class="tag">&lt;/dependency&gt;</span>
<span class="tag">&lt;/dependencies&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="creating-across-application"><a class="anchor" href="#creating-across-application"></a>1. Creating an Across application</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Usually an Across application is created for a web scenario and <code>@AcrossApplication</code>.
This configures your application and starts it up as a Spring Boot application.</p>
</div>
<div class="paragraph">
<p>Behind the scenes, <code>@AcrossApplication</code> uses <code>@EnableAcrossContext</code>.
The latter can also be used for defining an Across context on a configuration class, but without the Spring Boot application support.</p>
</div>
<div class="sect2">
<h3 id="across-application-fundamentals"><a class="anchor" href="#across-application-fundamentals"></a>1.1. Fundamentals</h3>
<div class="paragraph">
<p>When creating an Across application, we create an <code>*Application</code> class, which defines which modules should be bootstrapped in our application.
However, Across also expects an application module, which defines the logic that our application needs. The <code>application</code> package will define the application module.</p>
</div>
<div class="paragraph">
<p>Example package structure</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>| java
  | com.examples.my
    | application
    \ MyApplication.java
| resources
  \ views
    | static
      | my
      \ *.js
    \ th
      | my
      \ *.html</code></pre>
</div>
</div>
<div class="paragraph">
<p>One notable difference from a typical Across module is that all classes under the <code>application</code> package and its subpackages will be scanned for components, instead of the default config and extensions sub-packages.
This means, if we&#8217;d for example like to add a controller, we can simply define our class under the application package (or a sub-package) with the correct annotations.</p>
</div>
<div class="paragraph">
<p>Package structure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>| java
  | com.examples.my
    | application
      | web
        \ HelloController.java
    \ MyApplication.java
| resources
  \ views
    | static
      | my
        \ js
          \ main.js
        \ css
          \ main.css
    \ th
      | my
        \ homepage.html</code></pre>
</div>
</div>
<div class="paragraph">
<p>Example controller:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">com.examples.my.application.web</span>

<span class="annotation">@Controller</span>
<span class="namespace">public</span> <span class="namespace">class</span> <span class="namespace">HelloController</span>{

    <span class="annotation">@RequestMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/</span><span class="delimiter">&quot;</span></span>)
    <span class="namespace">public</span> <span class="namespace">String</span> <span class="namespace">home</span>(){
        <span class="namespace">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">th/my/homepage</span><span class="delimiter">&quot;</span></span>
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The above controller will be automatically picked up and registered as a bean. As we can see, we&#8217;ve mapped the root path "/" to a static template.
This template will be present under <code>resources/th/my</code> folder.</p>
</div>
<div class="paragraph">
<p>The across framework by default configures resource handlers for the web resources in the static/css/js folders under the resources/views folder.
As well as provides a ThymeleafViewResolver for the resources under the resources/th.</p>
</div>
</div>
<div class="sect2">
<h3 id="enable-across-context"><a class="anchor" href="#enable-across-context"></a>1.2. @EnableAcrossContext</h3>
<div class="paragraph">
<p>Usually your application will consist of a single <code>AcrossContext</code> that is configured in the main Spring <code>ApplicationContext</code>.
You can enable the automatic creation of an <code>AcrossContext</code> by putting the <code>@EnableAcrossContext</code> on any <code>@Configuration</code> class.
This will initialize a new <code>AcrossContext</code> with the main <code>ApplicationContext</code> as parent, look for a <a href="#across-datasource">default datasource bean</a> named <strong>acrossDataSource</strong> and then configure modules based on the <code>@EnableAcrossContext</code> attribute values.</p>
</div>
<div class="sect3">
<h4 id="acrosscontext-autoconfiguration"><a class="anchor" href="#acrosscontext-autoconfiguration"></a>1.2.1. AcrossContext autoconfiguration</h4>
<div class="paragraph">
<p>By default autoconfiguration of the <code>AcrossContext</code> will be enabled.
This implies that all <code>AcrossModule</code> beans from the parent <code>ApplicationContext</code> will be configured, along with any modules specified by name on <code>@EnableAcrossContext</code>.</p>
</div>
<div class="paragraph">
<p>When autoconfiguration is enabled, packages will be scanned to find valid module classes.
Unless packages are configured manually using the <strong>modulePackages</strong> or <strong>modulePackageClasses</strong> attributes, the <em>com.foreach.across.modules</em> package along with the package of the declaring <code>@Configuration</code> class will be scanned.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
If you use <code>@EnableAcrossContext</code> on a top-level class (no package specified), package <em>modules</em> and <em>com.foreach.across.modules</em> will be used for default scanning.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Scanning for modules in itself does not add any modules to the <code>AcrossContext</code>.
It simply maps all modules that could be autoconfigured on their unique name.
For a module to be autoconfigurable it should adhere to certain conventions, see the section on <a href="developing-modules.html#creating-an-across-module">creating an Across module</a> for more details.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The module scanning packages and settings can be controlled through attributes on <code>@EnableAcrossContext</code>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
A module name should be unique.
If you have more than one module with the same name, the last module scanned will take precedence.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">Minimal example of using @EnableAcrossContext</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">/**
 * Minimal configuration that will attempt to resolve module MyCustomModule:
 * - in the standard modules package (com.foreach.across.modules)
 * - in the package that AppConfiguration belongs to
 *
 * If found, MyCustomModule and its required dependencies will be added to the AcrossContext.
 * If not found, AcrossContext bootstrapping will fail.
 */</span>
<span class="annotation">@Configuration</span>
<span class="annotation">@EnableAcrossContext</span>( <span class="string"><span class="delimiter">&quot;</span><span class="content">MyCustomModule</span><span class="delimiter">&quot;</span></span> )
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfiguration</span>
{
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you want to customize the module configuration or a module is not autoconfigurable, you can add it as a bean in the parent <code>ApplicationContext</code> instead.</p>
</div>
<div class="listingblock">
<div class="title">Example adding a module as a bean</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">/**
 * AcrossWebModule is added to the AcrossContext by name.
 *
 * MyCustomModule is added as a bean in the ApplicationContext.
 * Because the bean implements AcrossModule, it will also be added to the AcrossContext.
 *
 * All required dependencies of either module will also be added if they can be found through scanning.
 */</span>
<span class="annotation">@Configuration</span>
<span class="annotation">@EnableAcrossContext</span>( AcrossWebModule.NAME )
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfiguration</span>
{
    <span class="annotation">@Bean</span>
    <span class="directive">public</span> MyCustomModule myCustomModule() {
        <span class="keyword">return</span> <span class="keyword">new</span> MyCustomModule();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As the previous example shows, you can safely combine beans and named module configuration.
Modules are configured in a certain order:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Modules defined by name on <code>@EnableAcrossContext</code></p>
</li>
<li>
<p>Module beans detected in the <code>ApplicationContext</code></p>
</li>
<li>
<p>Modules added through <a href="#acrosscontextconfigurer"><code>AcrossContextConfigurer</code> instances</a></p>
</li>
<li>
<p>Missing module dependencies resolved during bootstrap</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>If a module with the same name gets added more than once, the last version added will always win.</p>
</div>
</div>
<div class="sect3">
<h4 id="acrosscontextconfigurer"><a class="anchor" href="#acrosscontextconfigurer"></a>1.2.2. Customizing the AcrossContext</h4>
<div class="paragraph">
<p>After initial configuration but before bootstrapping, the configured <code>AcrossContext</code> will be delegated to all <code>AcrossContextConfigurer</code> beans it can find in the <code>ApplicationContext</code>.
This allows for changing any settings before the actual bootstrap happens.</p>
</div>
<div class="listingblock">
<div class="title">Example customizing an AcrossContext</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@EnableAcrossContext</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">WebConfiguration</span> <span class="directive">implements</span> AcrossContextConfigurer
{
        <span class="annotation">@Bean</span>
        <span class="directive">public</span> <span class="predefined-type">DataSource</span> acrossDataSource() {
                BasicDataSource dataSource = <span class="keyword">new</span> BasicDataSource();
                dataSource.setDriverClassName( <span class="string"><span class="delimiter">&quot;</span><span class="content">org.hsqldb.jdbc.JDBCDriver</span><span class="delimiter">&quot;</span></span> );
                dataSource.setUrl( <span class="string"><span class="delimiter">&quot;</span><span class="content">jdbc:hsqldb:mem:/hsql/testDataSource</span><span class="delimiter">&quot;</span></span> );
                dataSource.setUsername( <span class="string"><span class="delimiter">&quot;</span><span class="content">sa</span><span class="delimiter">&quot;</span></span> );
                dataSource.setPassword( <span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span> );

                <span class="keyword">return</span> dataSource;
        }

        <span class="annotation">@Override</span>
        <span class="directive">public</span> <span class="type">void</span> configure( AcrossContext context ) {
                context.setDevelopmentMode( <span class="predefined-constant">true</span> );

                context.addModule( <span class="keyword">new</span> SomeModule() );
        }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="across-application"><a class="anchor" href="#across-application"></a>1.3. @AcrossApplication</h3>
<div class="paragraph">
<p><code>@AcrossApplication</code> annotation can be used as an alternative for <code>@EnableAcrossContext</code> and <code>@SpringBootApplication</code> when defining an application.
In addition to default context configuration options, it also adds selected <a href="spring-boot.html#spring-boot">Spring Boot autoconfiguration classes</a> and enables <a href="#dynamic-across-modules">dynamic modules</a>.</p>
</div>
<div class="paragraph">
<p>Using <code>@AcrossApplication</code> is probably the easiest way to setup a simple (Spring Boot based) application backed by an AcrossContext.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Using <code>@EnableAutoConfiguration</code> and Spring Boot starters directly with Across is currently not supported.
Only a selected number of starters have support directly built into Across.
See <a href="spring-boot.html#spring-boot">Auto-configuration support</a> for more background information.
It is also possible to disable specific autoconfiguration classes using the <strong>exclude</strong> attribute on @AcrossApplication.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="embedded-servlet-container"><a class="anchor" href="#embedded-servlet-container"></a>1.3.1. Embedded servlet container</h4>
<div class="paragraph">
<p>Using <code>@AcrossApplication</code> adds the necessary Spring Boot auto configuration classes for embedded servlet containers.
If you have for example <strong>spring-boot-starter-tomcat</strong> on the classpath, you can run an Across based application inside an embedded Tomcat using <code>SpringApplication</code>.</p>
</div>
<div class="listingblock">
<div class="title">Minimal example of a Spring Boot based Across application</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@AcrossApplication</span>(modules = { MyModule.NAME, MyOtherModule.NAME })
<span class="directive">public</span> <span class="type">class</span> <span class="class">MyApplication</span>
{
        <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main( <span class="predefined-type">String</span><span class="type">[]</span> args ) {
                SpringApplication.run( MyApplication.class, args );
        }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="dynamic-across-modules"><a class="anchor" href="#dynamic-across-modules"></a>1.3.2. Dynamic Across modules</h4>
<div class="paragraph">
<p>Using <code>@AcrossApplication</code> on a class will automatically enable dynamic Across modules on that class.
Before bootstrapping the context, the configurator will attempt to find an application specific infrastructure, application or postprocessor module.
The name of the expected module is generated based on the name of the importing class.
If no module with that name can be resolved, the configurator will see if a child package is present relative to the package of the importing class.
Depending on the child package name, a dynamic module will be generated.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Importing class</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">MyApplication</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">MyConfiguration</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Infrastructure module</strong><br>
package: <em>infrastructure</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">MyApplicationInfrastructureModule<br>
resources: myApplicationInfrastructure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">MyConfigurationInfrastructureModule<br>
resources: myConfigurationInfrastructure</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Application module</strong><br>
package: <em>application</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">MyApplicationModule<br>
resources: <strong>my</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">MyConfigurationApplicationModule<br>
resources: <strong>myConfiguration</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>PostProcessor module</strong><br>
package: <em>postprocessor</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">MyApplicationPostProcessorModule<br>
resources: myApplicationPostProcessor</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">MyConfigurationPostProcessorModule<br>
resources: myConfigurationPostProcessor</p></td>
</tr>
</tbody>
</table>
<div class="listingblock">
<div class="title">Example package structure for application modules</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">com.mypackage
  MyApplication.class
  application.config
    MyApplicationModuleConfiguration.class
  infrastructure.installers
    SchemaInstallerToRunBeforeAnyOtherModule.class</code></pre>
</div>
</div>
<div class="paragraph">
<p>Disabling dynamic modules on an <code>@AcrossApplication</code> can be done through the <strong>enableDynamicModules</strong> attribute.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Dynamic modules perform an automatic component scan of all their child packages with the exception of <em>installers</em> and <em>extensions</em>.
If you want the default behavior of scanning only the <em>config</em> child package, you must provide an <code>AcrossModule</code> implementation.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you want to manually add dynamic modules, please see the javadoc for <code>AcrossDynamicModulesConfigurer</code> and <code>AcrossDynamicModulesConfiguration</code>.
</td>
</tr>
</table>
</div>
<h3 id="manual-configuration" class="discrete">Manual configuration</h3>
<div class="paragraph">
<p>An <code>AcrossContext</code> can be also configured manually and is started using the <code>bootstrap()</code> method, and stopped using <code>shutdown()</code>.
These methods take care of the Spring <code>ApplicationContext</code> lifecycle of all modules configured in the context.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">AcrossContext context = <span class="keyword">new</span> AcrossContext();
context.setParentApplicationContext( optionalParentContext );
context.setDataSource( someDataSource );
context.addModule( <span class="keyword">new</span> SomeModule() );

<span class="comment">// Start the context</span>
context.bootstrap();

<span class="comment">// Stop the context</span>
context.shutdown();</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="module-configuration"><a class="anchor" href="#module-configuration"></a>2. Module configuration</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Apart from module settings, an application can also define a number of <code><a href="developing-modules.html#module-configuration">@ModuleConfiguration</a></code> classes to be added to the bootstrapping modules.
When using the <code>@EnableAcrossContext</code>, the packages to scan for these can be set using attributes, but by default the sub-packages <strong>config</strong> and <strong>extensions</strong> of the importing class will be used.</p>
</div>
<div class="paragraph">
<p>Alternatively the packages to scan can be controlled via the <code>moduleConfigurationScanPackages</code> property on <code>AcrossContext</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="across-bootstrap"><a class="anchor" href="#across-bootstrap"></a>3. Across bootstrap</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Across bootstrap is the actual starting of the application.
During the bootstrapping phase the entire Spring <code>ApplicationContext</code> hierarchy of an application is created.</p>
</div>
<div class="paragraph">
<p>A typical Across application has the following bootstrap phases:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The root <code>ApplicationContext</code> is scanned, which includes the configuration of the Across context (represented by the <code>@AcrossApplication</code> annotation).</p>
</li>
<li>
<p>The <code>AcrossContext</code> bean is created as early as possible:</p>
<div class="ulist">
<ul>
<li>
<p>the Across context configuration is analyzed and the modules are ordered according to their dependencies;</p>
</li>
<li>
<p>the different module descriptors are offered a chance to customize the Across context configuration;</p>
</li>
<li>
<p>the parent Across <code>ApplicationContext</code> is created to serve as parent for the <code>ApplicationContext</code> of individual modules;</p>
</li>
<li>
<p>every module creates its own <code>ApplicationContext</code> in the order assigned by the Across context;</p>
</li>
<li>
<p>exposed beans are pushed up the <code>ApplicationContext</code> hierarchy as far as possible.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Other beans in the root <code>ApplicationContext</code> are created; these can optionally use exposed components from the Across modules.</p>
</li>
<li>
<p>The root <code>ApplicationContext</code> returns and is ready to be used. In case of a Spring Boot application, the Spring <code>ApplicationReadyEvent</code> gets published.</p>
</li>
</ol>
</div>
<div class="sect2">
<h3 id="module-bootstrap-order"><a class="anchor" href="#module-bootstrap-order"></a>3.1. Module bootstrap order</h3>
<div class="paragraph">
<p>During bootstrap the Across context will inspect the dependencies between modules, and will determine the order in which modules should be started.
Once the order has been determined, the modules will be started one by one.</p>
</div>
</div>
<div class="sect2">
<h3 id="installers"><a class="anchor" href="#installers"></a>3.2. Installers</h3>
<div class="paragraph">
<p>At several points during bootstrap of an Across context, <a href="developing-modules.html#installer-bootstrap-phases">installers can get executed</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="bootstrap-events"><a class="anchor" href="#bootstrap-events"></a>3.3. Bootstrap events</h3>
<div class="paragraph">
<p>During bootstrap, the Across context <a href="#dev-appl-bootstrap-events">publishes several events</a> that allow other components to act upon.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="properties"><a class="anchor" href="#properties"></a>4. Properties</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Both AcrossModule and AcrossContext have a collection of Properties.
These can be accessed directly from the instance, but will also be registered as <code>PropertySource</code> in the bootstrapping <code>ApplicationContext</code>.
Across favours the PropertySource/Environment approach over the concept of multiple PropertyPlaceholderConfigurer.
Reasoning behind this is <a href="https://jira.spring.io/browse/SPR-8539?focusedCommentId=75569&amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-75569">explained here as a comment on a Spring issue</a>.</p>
</div>
<h3 id="registering-additional-propertysources" class="discrete">Registering additional PropertySources</h3>
<div class="paragraph">
<p>Apart from the Properties directly on AcrossModule and AcrossContext instances, there are methods to register additional PropertySources to a module or context.
PropertySources or properties configured on a module, will only be available within that module; whereas PropertySources or properties on the context will be available in all modules.
Because PropertySource is most often based on an actual Resource file, the addPropertySources() methods allow direct usage of Resource instances.
If the Resource does not exist, it is simply ignored.</p>
</div>
<h3 id="propertysource-priority" class="discrete">PropertySource priority</h3>
<div class="paragraph">
<p>Within the context or module, the order in which PropertySources have been registered determines the order of looking for the property values.
In a context/module hierarchy, the following order is used:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>properties set directly on the current AcrossModule</p>
</li>
<li>
<p>PropertySources attached to the current AcrossModule (last one added first)</p>
</li>
<li>
<p>properties set directly on the AcrossContext</p>
</li>
<li>
<p>PropertySources attached to the AcrossContext (last one added first)</p>
</li>
<li>
<p>PropertySources registered in the parent ApplicationContext</p>
</li>
</ol>
</div>
<h3 id="accessing-properties-in-modules" class="discrete">Accessing properties in modules</h3>
<div class="paragraph">
<p>Accessing properties in modules is no different than in standard Spring.
By default all properties can be accessed using the Environment.</p>
</div>
<div class="listingblock">
<div class="title">Example using Environment</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">Config</span>
{
    <span class="annotation">@Bean</span>
    <span class="directive">public</span> AcrossContext acrossContext( ConfigurableApplicationContext applicationContext ) <span class="directive">throws</span> <span class="exception">Exception</span> {
        AcrossContext context = <span class="keyword">new</span> AcrossContext( applicationContext );
        context.setDataSource( acrossDataSource() );
        context.setAllowInstallers( <span class="predefined-constant">true</span> );

        <span class="comment">// Configure some properties</span>
        context.setProperty( <span class="string"><span class="delimiter">&quot;</span><span class="content">directProperty</span><span class="delimiter">&quot;</span></span>, <span class="integer">789</span> );
        context.addPropertySources( <span class="keyword">new</span> ClassPathResource(<span class="string"><span class="delimiter">&quot;</span><span class="content">my.properties</span><span class="delimiter">&quot;</span></span>) );

        context.addModule( testModule1() );
        context.addModule( testModule2() );
        <span class="keyword">return</span> context;
    }
}

<span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">ConfigInModule</span>{
    <span class="annotation">@Autowired</span>
    <span class="directive">private</span> Environment environment;

    <span class="annotation">@Bean</span>
    <span class="directive">public</span> MyBean myBean() {
        <span class="keyword">return</span> <span class="keyword">new</span> MyBean( environment.getProperty( <span class="string"><span class="delimiter">&quot;</span><span class="content">my.property</span><span class="delimiter">&quot;</span></span> ) );
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you want to use placeholders you must add a PropertySourcesPlaceholderConfigurer to every module where you want placeholders to be resolved.
Because of the way BeanFactoryPostProcessors and PropertyPlaceholderConfigurers work, it is best to configure a new instance in every module, instead of passing a shared postprocessor to all modules.
A default ApplicationContextConfigurer is available in the PropertyPlaceholderSupportConfigurer class.
In practice however: it should be the responsibility of the module to configure a PropertyPlaceholderConfigurer if it uses placeholders!</p>
</div>
<div class="listingblock">
<div class="title">Example using PropertySources and simple property placeholder resolving</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">Config</span>
{
    <span class="annotation">@Bean</span>
    <span class="directive">public</span> AcrossContext acrossContext( ConfigurableApplicationContext applicationContext ) <span class="directive">throws</span> <span class="exception">Exception</span> {
        AcrossContext context = <span class="keyword">new</span> AcrossContext( applicationContext );
        context.setDataSource( acrossDataSource() );
        context.setAllowInstallers( <span class="predefined-constant">true</span> );

        <span class="comment">// Configure some properties</span>
        context.setProperty( <span class="string"><span class="delimiter">&quot;</span><span class="content">directProperty</span><span class="delimiter">&quot;</span></span>, <span class="integer">789</span> );
        context.addPropertySources( <span class="keyword">new</span> ClassPathResource(<span class="string"><span class="delimiter">&quot;</span><span class="content">my.properties</span><span class="delimiter">&quot;</span></span>) );

        <span class="comment">// Register the property placeholder resolving in every module</span>
        context.addApplicationContextConfigurer( <span class="keyword">new</span> PropertyPlaceholderSupportConfigurer(),
                                                 ConfigurerScope.CONTEXT_AND_MODULES );

        context.addModule( testModule1() );
        context.addModule( testModule2() );
        <span class="keyword">return</span> context;
    }
}

<span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">ConfigInModule</span> {
    <span class="annotation">@Bean</span>
    <span class="directive">public</span> MyBean myBean( <span class="annotation">@Value</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">${my.property}</span><span class="delimiter">&quot;</span></span>) <span class="predefined-type">String</span> myProperty ) {
        <span class="keyword">return</span> <span class="keyword">new</span> MyBean( environment.getProperty( myProperty  ) );
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example using custom property placeholder resolving</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// Import inner class to make resolver available both in parent as in Across context</span>
<span class="annotation">@Configuration</span>
<span class="annotation">@Import</span>(CustomPropertyConfig.class)
<span class="directive">public</span> <span class="type">class</span> <span class="class">Config</span>
{
    <span class="annotation">@Configuration</span>
    <span class="directive">public</span> <span class="directive">static</span> <span class="type">class</span> <span class="class">CustomPropertyConfig</span>
    {
        <span class="annotation">@Bean</span>
        <span class="directive">public</span> <span class="directive">static</span> PropertySourcesPlaceholderConfigurer properties() {
            PropertySourcesPlaceholderConfigurer configurer = <span class="keyword">new</span> PropertySourcesPlaceholderConfigurer();
            configurer.setLocation( <span class="keyword">new</span> ClassPathResource( <span class="string"><span class="delimiter">&quot;</span><span class="content">my.properties</span><span class="delimiter">&quot;</span></span> ) );
            <span class="keyword">return</span> configurer;
        }
    }

    <span class="annotation">@Bean</span>
    <span class="directive">public</span> AcrossContext acrossContext( ConfigurableApplicationContext applicationContext ) <span class="directive">throws</span> <span class="exception">Exception</span> {
        AcrossContext context = <span class="keyword">new</span> AcrossContext( applicationContext );
        context.setDataSource( acrossDataSource() );
        context.setAllowInstallers( <span class="predefined-constant">true</span> );

        <span class="comment">// Register the property placeholder resolving in every module</span>
        context.addApplicationContextConfigurer( <span class="keyword">new</span> AnnotatedClassConfigurer( CustomPropertyConfig.class ),
                                                 ConfigurerScope.CONTEXT_AND_MODULES );


        context.addModule( testModule1() );
        context.addModule( testModule2() );
        <span class="keyword">return</span> context;
    }
}

<span class="annotation">@Component</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">SomeBeanInModule</span> {
    <span class="annotation">@Value</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">${my.property}</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">private</span> <span class="predefined-type">String</span> someValueFromProperty;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="across-datasource"><a class="anchor" href="#across-datasource"></a>5. Across datasource</h2>
<div class="sectionbody">
<div class="paragraph">
<p>An Across context supports the configuration of a SQL database <code>DataSource</code> instance.
If there is a primary <code>DataSource</code> or only a single <code>DataSource</code> bean available, Across will automatically use that one.</p>
</div>
<div class="paragraph">
<p>The datasource will be available for all modules as a bean named <strong>acrossDataSource</strong>.
Additionally a second datasource can be configured that will be available as the <strong>acrossInstallerDataSource</strong>.
If no separate installer datasource is specified, the default across datasource will be used.</p>
</div>
<div class="paragraph">
<div class="title">Installers</div>
<p>Across only actually needs a datasource if you want to execute installers or use the <code>DistributedLockRepository</code> directly.
The datasource is used for keeping track of which installers have been executed.</p>
</div>
<div class="paragraph">
<p>See for more information on working with SQL databases in an Across application, see the <a href="#sql-databases">separate chapter</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="events"><a class="anchor" href="#events"></a>6. Events</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Modules in an Across application often use events to communicate with each other.
To this end, Across fully supports the Spring framework event listening features.</p>
</div>
<div class="paragraph">
<p>This chapter lists the most common event features, please refer to the <a href="https://docs.spring.io/spring/docs/4.3.14.RELEASE/spring-framework-reference/htmlsingle/#context-functionality-events">Spring framework documentation</a> for all details.</p>
</div>
<div class="sect2">
<h3 id="subscribing-to-events"><a class="anchor" href="#subscribing-to-events"></a>6.1. Subscribing to events</h3>
<div class="paragraph">
<p>The most common way to subscribe to an event is by simply providing an <code>@EventListener</code> annotated method.
A single object can have many listener methods.
All beans created in the <code>ApplicationContext</code> are automatically scanned for event listener methods.</p>
</div>
<div class="listingblock">
<div class="title">Example component with an event listener method</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Component</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">MyHandler</span> {
    <span class="annotation">@EventListener</span>
    <span class="directive">public</span> <span class="type">void</span> handle( SomeEvent event ) {
        <span class="comment">// Called whenever an event of type SomeEvent is published</span>
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="publishing-events"><a class="anchor" href="#publishing-events"></a>6.2. Publishing events</h3>
<div class="paragraph">
<p>Publishing events is done via the <code>ApplicationEventPublisher</code> bean.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Autowired</span>
<span class="directive">private</span> ApplicationEventPublisher eventPublisher;

<span class="directive">public</span> <span class="type">void</span> sendEvent() {
  eventPublisher.publishEvent( <span class="keyword">new</span> SomeEvent() );
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="filtering-events"><a class="anchor" href="#filtering-events"></a>6.3. Filtering events</h3>
<div class="paragraph">
<p>Event listeners can subscribe to specific events using one of several mechanisms:</p>
</div>
<div class="listingblock">
<div class="title">Setting a specific (base) class as the event argument on an @EventListener method</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@EventListener</span>
<span class="directive">public</span> <span class="type">void</span> handle( SomeEvent event ) {
    <span class="comment">// Called whenever an event of type SomeEvent is published</span>
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Setting one or more base classes on the @EventListener annotation</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@EventListener</span>( {SomeEvent.class, SomeOtherEvent.class} )
<span class="directive">public</span> <span class="type">void</span> handleEvents() {
    <span class="comment">// In this case a method parameter is not actually required</span>
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Using the SpEL condition attribute on the @EventListener annotation</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@EventListener</span>(condition = <span class="string"><span class="delimiter">&quot;</span><span class="content">#event.eventName == 'myEvent'</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">void</span> handle( NamedEvent event ) {
    <span class="comment">// Called if the event is of type NamedEvent</span>
    <span class="comment">// and property 'eventName' has the value 'myEvent'</span>
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Using a generic event with type parameters</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@EventListener</span>
<span class="directive">public</span> <span class="type">void</span> onManCreated( EntityCreatedEvent&lt;Man&gt; event ) {
    <span class="comment">// Called if the generic type is exactly Man</span>
}

<span class="annotation">@EventListener</span>
<span class="directive">public</span> <span class="type">void</span> onHumanCreated( EntityCreatedEvent&lt;? <span class="directive">extends</span> Human&gt; event ) {
    <span class="comment">// Called whenever the generic type implements Human</span>
}


<span class="comment">// The event must implement ResolvableTypeProvider if it is not a specific class</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">EntityCreatedEvent</span>&lt;T&gt; <span class="directive">implements</span> ResolvableTypeProvider {
    <span class="directive">private</span> <span class="directive">final</span> T entity;

    <span class="directive">public</span> EntityCreatedEvent( T entity ) {
        <span class="local-variable">this</span>.entity = entity;
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> ResolvableType getResolvableType() {
        <span class="keyword">return</span> ResolvableType.forClassWithGenerics( getClass(), ResolvableType.forInstance( entity ) );
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="asynchronous-listeners"><a class="anchor" href="#asynchronous-listeners"></a>6.4. Asynchronous listeners</h3>
<div class="paragraph">
<p>You can use a <code>@Async</code> to handle events asynchronously.
This has some limitations, see the <a href="https://docs.spring.io/spring/docs/4.3.14.RELEASE/spring-framework-reference/htmlsingle/#context-functionality-events-async">Spring framework documentation</a>.</p>
</div>
<div class="paragraph">
<p>Please note as well that asynchronous execution must be enabled in the module where you register the event listener.</p>
</div>
</div>
<div class="sect2">
<h3 id="event-handler-ordering"><a class="anchor" href="#event-handler-ordering"></a>6.5. Ordering listeners</h3>
<div class="paragraph">
<p>Ordering of listeners is one of the aspects where an Across application differs from default Spring <code>ApplicationContext</code> behaviour.</p>
</div>
<div class="paragraph">
<p>When a module publishes an event, it will be received by all other modules in bootstrap order.
This means that event listeners from a previous module might handle the event before listeners from the module that actually published it.
By default, listener methods from the same across module do not have a specific order assigned.</p>
</div>
<div class="paragraph">
<p>The default ordering is reliable and works best for most use cases: you can rely on event listeners from previous modules having been executed before you.
Thus, listeners registered in your application module will usually fire last.</p>
</div>
<div class="paragraph">
<p>Once an event has been handled by all modules, it will be sent to the (optional) parent <code>ApplicationContext</code>.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Events published directly from a parent <code>ApplicationContext</code> - for example directly from within your <code>@AcrossApplication</code> class - will not be sent downstream to the modules!
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Just like with other Across related ordering, you can influence the default behaviour:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>use <code>@OrderInModule</code> on your methods to order listener execution within the same module</p>
</li>
<li>
<p>use <code>@Order</code> on your methods to suppress the default module bootstrap order and order listeners explicitly</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="refreshing"><a class="anchor" href="#refreshing"></a>7. Refreshing</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The AcrossContext is refreshed once, right before it is fully bootstrapped.
Refresh happens after all individual modules have bootstrapped and all beans have been exposed, but before the after-bootstrap installers have run.</p>
</div>
<div class="paragraph">
<p>There are several ways to hook into the refresh phase:</p>
</div>
<div class="sect2">
<h3 id="refreshable"><a class="anchor" href="#refreshable"></a>7.1. @Refreshable</h3>
<div class="paragraph">
<p>Any bean annotated with <code>@Refreshable</code> will be autowired twice.
Once when it gets created, and once when the AcrossContext is refreshed.
You can use this for optional dependencies where the value might be exposed by a later module.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Although the functionality is there, you should probably avoid using <code>@Refreshable</code> and prefer <code>@PostRefresh</code> or subscribing to one of the bootstrap related events.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="post-refresh"><a class="anchor" href="#post-refresh"></a>7.2. @PostRefresh</h3>
<div class="paragraph">
<p>Much like <code>@PostConstruct</code>, a bean can have one or more <code>@PostRefresh</code> methods.
These will be executed when the AcrossContext is refreshed.</p>
</div>
</div>
<div class="sect2">
<h3 id="refreshable-collection"><a class="anchor" href="#refreshable-collection"></a>7.3. @RefreshableCollection</h3>
<div class="paragraph">
<p><code>@RefreshableCollection</code> is an annotation to qualify dependencies being autowired.
It can only be used on dependencies of type <code>Collection</code>.</p>
</div>
<div class="paragraph">
<p>When using <code>@RefreshableCollection</code>, instead of a regular collection of beans, a <code><a href="#refreshable-registry">RefreshableRegistry</a></code> will be wired.
The behaviour and type of the <code>RefreshableRegistry</code> can be determined through the annotation attributes.</p>
</div>
<div class="listingblock">
<div class="title">Example autowiring collection that will contain all MyBean instances from all modules, even if not exposed</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Autowired</span>
<span class="directive">public</span> <span class="type">void</span> setMyBeans( <span class="annotation">@RefreshableCollection</span>(includeModuleInternals=<span class="predefined-constant">true</span>) <span class="predefined-type">Collection</span>&lt;MyBean&gt; myBeans ) {
    <span class="local-variable">this</span>.myBeans = myBeans;
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="refreshable-registry"><a class="anchor" href="#refreshable-registry"></a>7.4. RefreshableRegistry</h3>
<div class="paragraph">
<p>A <code>RefreshableRegistry</code> is a collection of beans of a specified class that updates itself once when the AcrossContext is refreshed.
A <code>RefreshableRegistry</code> can also scan for beans inside the other modules in the running context, without the need for those beans to be exposed.
This allows other modules to pick up extensions or configurations from other modules that bootstrap later.</p>
</div>
<div class="paragraph">
<p>The value of a <code>RefreshableRegistry</code> are also ordered according to the <a href="#bean-order">Across module order hierarchy</a>.</p>
</div>
<div class="paragraph">
<p><code>IncrementalRefreshableRegistry</code> is a specialization that updates its values every time a module has bootstrapped.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="bean-order"><a class="anchor" href="#bean-order"></a>8. Bean order</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In an Across based application, the primary order of bean interaction should be defined by the module dependencies.
When scanning for beans in all modules (eg. when using a <code>RefreshableRegistry</code> or <code>@RefreshableCollection</code>), the beans will be returned according to the module order: beans from earlier bootstrapped modules will be before beans from later modules.
The reasoning is simple: <em>if I depend on module A, i can rely on module A having done its things before I will</em>.
If you need more sophisticated ordering, there are two extension points to the default behavior:</p>
</div>
<div class="paragraph">
<div class="title">Order annotation and Ordered interface</div>
<p>Core Spring classes.
If you define these on beans, these will take precedence over the order of the modules themselves.
The <code>Ordered</code> interface takes precedence over an <code>@Order</code> annotation, if both are present.
Using global ordering should be avoided as much as possible, but using for example <code>Ordered.LOWEST_PRECEDENCE</code> you can ensure that a bean comes after all other context created beans in the list.</p>
</div>
<div class="paragraph">
<div class="title">OrderInModule annotation and OrderedInModule interface</div>
<p>The equivalent of <code>@Order</code> and <code>Ordered</code>, but they only apply within a single module.
Use these if you have multiple beans (eg security configurers) of the same type in a single module, and it is important they follow a sequence.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Unless a specific order is given either through the interface or annotation, a default order of <code>Ordered.LOWEST_PRECEDENCE - 1000</code> is applied.
This way you can still force beans to be ordered behind beans without an explicit order.
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
The current version of Across does not apply the module order hierarchy to event handlers.
If event handlers need an order, it should be defined explicitly and you cannot rely that event handlers from other modules you depend on will have been executed before you.
This is an important work in progress for one of the next versions of Across.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="conversion-service"><a class="anchor" href="#conversion-service"></a>9. ConversionService</h2>
<div class="sectionbody">
<div class="paragraph">
<p>An AcrossContext requires a valid <code>ConversionService</code> bean named <strong>conversionService</strong> to be present.
If there is none, a <code>DefaultFormattingConversionService</code> will be created and exposed.
If you want to manage the <code>ConversionService</code> yourself, simply create a <code>ConversionService</code> with the right name in the parent <code>ApplicationContext</code>.</p>
</div>
<div class="paragraph">
<p>The default <strong>conversionService</strong> will also be attached to the <code>ApplicationContext</code> environment of every module.
This means property fetching using <code>Environment.getProperty()</code> methods will perform type conversion using the <code>ConversionService</code> (eg. useful for date property parsing).</p>
</div>
<div class="paragraph">
<div class="title">Date conversion</div>
<p>Apart from the <code>ConversionService</code> itself, an <code>AcrossContext</code> creates a default <code>StringToDateConverter</code> bean named <strong>defaultDateConverter</strong>.
This converter supports converting a string to a corresponding date in many common date patterns.
The <code>StringToDateConverter</code> assumes a fixed locale that can be configured (default: <code>US</code>).</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
If you manage the <code>ConversionService</code> outside of the <code>AcrossContext</code> the default <code>StringToDateConverter</code> will not be registered either.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="development-mode"><a class="anchor" href="#development-mode"></a>10. Development mode</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The AcrossContext can have development mode enabled through the <strong>developmentMode</strong> property.
Modules can use development mode to configure different services (or services differently).
An example is auto-reloading and no caching of the message sources if development mode is active.</p>
</div>
<div class="paragraph">
<p>Apart from setting the <strong>developmentMode</strong> property on <code>AcrossContext</code>, development mode can be activated the following way:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>property <strong>across.development.active</strong> is <em>true</em></p>
</li>
<li>
<p>Spring profile <strong>dev</strong> is active</p>
</li>
</ol>
</div>
<div class="paragraph">
<div class="title">Resource resolving</div>
<p>By default resources (eg. messages, templates) are resolved from the classpath.
It is possible to configure a physical location for the resources of a module if development mode is active (eg on your local filesystem).</p>
</div>
<div class="paragraph">
<p><em>Default location</em><br>
For simple Across based applications using <code>@AcrossApplication</code> it might be enough to simply activate development mode.
If the working directory of the running application contains a <strong>src/main/resources</strong> directory, this directory would be used for all dynamic modules, unless a specific value is set.
This would usually be the case for single maven module projects.</p>
</div>
<div class="paragraph">
<p><em>Specific module resource locations</em><br>
The path can be configured by adding the right property to the application properties, or specifying them in the development mode properties.
The development mode properties is a special properties file that by default will be looked for in <strong>${user.home}/dev-configs/across-devel.properties</strong>.</p>
</div>
<div class="paragraph">
<p>A resource location for the development mode properties can be specified by setting the <strong>across.development.properties</strong> property value.
Development mode properties are loaded using resource resolving, so classpath resources can be used as well (eg. <em>classpath:/dev.properties</em>).</p>
</div>
<div class="paragraph">
<p>The development mode properties file should contain properties where the key references the module name, and the value the physical resources directory.</p>
</div>
<div class="listingblock">
<div class="title">Example development properties</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text"># Absolute directory
acrossModule.MyModule.resources=c:/code/mymodule/src/main/resources
acrossModule.OtherModule.resources=c:/code/othermodule/src/main/resources

# Relative to the working directory
acrossModule.SomeModule.resources=some-module/src/main/resources</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Using relative paths can be an effective way to embed development properties in a multi-module maven project.
Paths should be relative to the working directory of the running application.
Depending on how you run the application, the working directory can differ.
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Properties added directly to the application properties will take precedence over those present in the development mode properties.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sql-databases"><a class="anchor" href="#sql-databases"></a>11. Working with SQL databases</h2>
<div class="sectionbody">
<div class="paragraph">
<p>An Across application supports virtually all features of a regular Spring Boot application when it comes to working with SQL databases.
You can automatically create a <code>DataSource</code> instance by setting the right properties and adding a starter like <code>spring-boot-starter-jdbc</code> or <code>spring-boot-starter-jpa</code>.</p>
</div>
<div class="listingblock">
<div class="title">Example configuring a datasource bean</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="properties">spring.datasource.url=jdbc:mysql://localhost/test
spring.datasource.username=dbuser
spring.datasource.password=dbpass
spring.datasource.driver-class-name=com.mysql.jdbc.Driver</code></pre>
</div>
</div>
<div class="paragraph">
<p>See the <a href="https://docs.spring.io/spring-boot/docs/1.5.10.RELEASE/reference/htmlsingle/#boot-features-sql">relevant Spring Boot documentation</a> for an overview of the possible features.
The rest of this chapter lists the most important differences between a regular Spring Boot and an Across application.</p>
</div>
<div class="sect2">
<h3 id="using-jdbctemplate"><a class="anchor" href="#using-jdbctemplate"></a>11.1. Using JdbcTemplate</h3>
<div class="paragraph">
<p>Currently not supported.</p>
</div>
</div>
<div class="sect2">
<h3 id="jpa-and-spring-data"><a class="anchor" href="#jpa-and-spring-data"></a>11.2. JPA and Spring Data</h3>
<div class="paragraph">
<p>When adding <code>spring-boot-starter-data-jpa</code> a JPA <code>EntityManager</code> using Hibernate 5 will be automatically created and available in the application module.
The <strong>application module package will be scanned for entities and Spring Data JPA repositories</strong>, in the same way as described in the <a href="https://docs.spring.io/spring-boot/docs/1.5.10.RELEASE/reference/htmlsingle/#boot-features-jpa-and-spring-data">Spring Boot documentation</a>.</p>
</div>
<div class="paragraph">
<p>Default support is limited to the application module however.
If you are looking for JPA support for multiple (shared) modules, you should look at the <a href="https://across.foreach.be/modules/AcrossHibernateJpaModule">AcrossHibernateJpaModule</a>.
Said module creates a shared <code>EntityManager</code> with a mapping context that other modules can extend.
It is also fully compatible with the default Spring Boot JPA support and can often be used as a simple drop-in replacement when switching from a simple application to having multiple modules with entities.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
When only using the <code>spring-boot-starter-data-jpa</code> the database schema will be created by default when using an embedded database.
When switching to AcrossHibernateJpaModule as a replacement, you will always have to specify the schema creation.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="validation"><a class="anchor" href="#validation"></a>12. Validation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>If a JSR-303 implementation (eg. Hibernate validator) is on the classpath, Bean Validation 1.1 will automatically be enabled in all modules.
A single <code>Validator</code> bean will be created with support for <code>javax.validation</code> constraints.</p>
</div>
<div class="paragraph">
<p>It can be used for manual validation of components, or for the use of <code>@Validated</code> on target classes.
The latter allows property/field validation (for example <a href="https://docs.spring.io/spring-boot/docs/1.5.10.RELEASE/reference/htmlsingle/#boot-features-external-config-validation">with <code>@ConfigurationProperties</code></a>) or <a href="https://docs.spring.io/spring-boot/docs/1.5.10.RELEASE/reference/htmlsingle/#boot-features-validation">method validation</a>.</p>
</div>
<div class="listingblock">
<div class="title">Hibernate validator JSR-303 implementation</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;dependency&gt;</span>
    <span class="tag">&lt;groupId&gt;</span>org.hibernate<span class="tag">&lt;/groupId&gt;</span>
    <span class="tag">&lt;artifactId&gt;</span>hibernate-validator<span class="tag">&lt;/artifactId&gt;</span>
<span class="tag">&lt;/dependency&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="advanced-topics"><a class="anchor" href="#advanced-topics"></a>13. Advanced topics</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="dev-appl-bootstrap-events"><a class="anchor" href="#dev-appl-bootstrap-events"></a>13.1. Lifecycle events</h3>
<div class="paragraph">
<p>When starting an Across context, a number of events are published.
These allow you to hook into the Across context lifecycle.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">AcrossModuleBeforeBootstrapEvent</dt>
<dd>
<p>Event that is sent for each module, right before it is bootstrapped.
The configuration of the module can still be modified at this point.
Modules will only receive this event for other modules that are started later during the bootstrap phase.</p>
</dd>
<dt class="hdlist1">AcrossModuleBootstrappedEvent</dt>
<dd>
<p>Event published when a module has bootstrapped.
That means the module itself has started, but installers attached to the <code>AfterModuleBootstrap</code> phase have not yet been executed.
Modules will only receive this event for other modules that are started later during the bootstrap phase.</p>
</dd>
<dt class="hdlist1">AcrossContextBootstrappedEvent</dt>
<dd>
<p>Event published after the AcrossContext has bootstrapped.
That means full initialization has happened: all modules are started and all installers have been executed.</p>
</dd>
</dl>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Because of component creation order, lifecycle events can often not be handled using regular <code>@EventListener</code> methods.
You should provide an <code>ApplicationListener</code> component for those events instead. A general purpose interface <code>AcrossLifecycleListener</code> can be implemented if you want to handle more than one lifecycle event.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="customizing-across-bootstrap"><a class="anchor" href="#customizing-across-bootstrap"></a>13.2. Customizing Across bootstrap</h3>
<div class="paragraph">
<p>If is possible to customize an Across context configuration after the modules have been assembled, but before the actual context or module starts.
There are two common ways to do this:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>handling the <code>AcrossModuleBeforeBootstrapEvent</code> and customizing the configuration of the module being started</p>
</li>
<li>
<p>providing one or more <code>AcrossBootstrapConfigurer</code> components in the parent <code>ApplicationContext</code></p>
<div class="ulist">
<ul>
<li>
<p>for example: have your <code>@AcrossApplication</code> annotated class implement the <code>AcrossBootstrapConfigurer</code> interface</p>
</li>
<li>
<p>this strategy is often used for providing auto-configuration support of third-party libraries</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>Additionally, a shared module can also modify the Across context configuration by implementing <code>prepareForBootstrap()</code> on its module descriptor.</p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 3.0.0.RELEASE<br>
Last updated 2018-03-29 16:27:59 CEST
</div>
</div>
<script>
    var link = document.createElement( "a" );
    link.setAttribute( "href", "index.html" );
    link.innerHTML = "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 82.9 95.7\" width=\"20\" style=\"margin-right: 10px\"><path fill=\"#3CA873\" d=\"M0 23.9l15.9-9.2 41.5 23.9-16 9.2\"></path><path fill=\"#0093D8\" d=\"M25.5 9.2L41.4 0l41.5 23.9-16 9.2\"></path><path fill=\"#53DD99\" d=\"M41.4 95.7l16-9.3V38.6l-16 9.2\"></path><path fill=\"#22CEFA\" d=\"M66.9 80.9l16-9.2V23.9l-16 9.2\"></path><path fill=\"#257A50\" d=\"M12.5 64.5L28.9 55l-16.4-9.4\"></path><path fill=\"#4DBC86\" d=\"M12.5 64.5L28.9 74V55\"></path></svg>"
            + "Across reference docs";
    var p = document.createElement( "p" );
    p.appendChild( link );
    var toc = document.getElementById( 'toc' );
    var next = document.getElementById( 'toctitle' );
    toc.insertBefore( p, next );
</script>
</body>
</html>